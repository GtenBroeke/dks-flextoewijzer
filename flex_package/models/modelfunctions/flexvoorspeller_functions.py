import numpy as np
import pandas as pd
import datetime
import csv
import boto3
import random
import flex_package.config as config
import awswrangler as wr


class Order:
    def __init__(self, time=None, size=None, origin=None, destination=None):
        self.Time = time
        self.Size = size
        self.Origin = origin
        self.Destination = destination


def read_afvoer_data(file):
    """
    Function that reads the 'afvoerline' predictions from a datafile generated by the 'afvoerlijnvoorspeller'
    :param file: path from which to read the datafile
    :return: DataFrame with predicted afvoer for each depot
    """
    df = wr.s3.read_csv(file)
    df['date_time'] = df['date_time'].apply(lambda x: datetime.datetime.strptime(x, '%d/%m/%Y %H:%M'))
    return df


def generate_destinations(origin, df_afv):
    """
    Generate a list of destinations to be considered for each depot of origin.
    :param origin: Depot from which the 'afvoer' is considered
    :param df_afv: Dataframe containing the 'afvoer' generated at each depot for crossdocks
    :return: List of destinations
    """
    destinations = list(df_afv[df_afv['origin'] == origin]['crossdock'].unique())
    if origin in destinations:
        destinations.remove(origin)
    if 'XXX' in destinations:
        destinations.remove('XXX')
    if 'SCB' in destinations:
        destinations.remove('SCB')
    if 'TGN' in destinations:
        destinations.remove('TGN')
    return destinations


def generate_afvoer_df(origin, destination, df_afv):
    """
    Generates the 'afvoer' between a specific depot and crossdock combination. Also computes the cumulative afvoer,
    which shows the total number of rc that have been generated at any specific time. Note that inter transports are not
    accounted for here. Thus, what is generated is the total afvoer for the depot-crossdock combination, without
    deducting any rollcages that are transported to the crossdock
    :param origin: Depot of origin
    :param destination: Crossdock
    :param df_afv: dataframe containing afvoer between all combinations of depot and crossdock
    :return: DataFrame with afvoer and cumulative afvoer for the depot-crossdock combination
    """
    df = df_afv[df_afv['origin'] == origin]
    df = df[df['crossdock'] == destination]
    df['Total'] = df['rc_forecast'].cumsum()
    return df


def generate_inter_df(origin, destination, df_int):
    """
    Generates a DataFrame with all inter transports between a specific depot and crossdock
    :param origin: Starting depot
    :param destination: Destination crossdock
    :param df_int: DataFrame with all inter transports
    :return: DataFrame with the inter transports between depot and crossdock
    """
    df = df_int[df_int['Afk laadlocatie'] == origin]
    df = df[df['Afk loslocatie'] == destination]
    return df


def generate_event_times(df_afv, df_int):
    """
    Makes a chronologically sorted list of all times at which an event takes place, and removes any duplicates. Events
    are either a new prediction of 'afvoer' from the afvoerlijnvoorspeller, or the arrival of an inter transport
    :param df_afv: DataFrame containing afvoer predictions
    :param df_int: DataFrame containing inter transports
    :return: List of event times
    """
    times = list(df_afv['date_time'])
    times.extend(list(df_int['loading_time']))
    times = np.unique(times)
    times.sort()
    return times


def add_new_afvoer(df_afv, afv, afv_time, origin, destination, time):
    """
    Add new afvoer to dataframe that keeps track of the total afvoer deficit over the day, for all depot-
    crossdock combinations. This is done separately based on afvoer predictions from the afvoerlijnvoorspeller, and
    based on scan data. Also, the afvoer is added to a dataframe that tracks the afvoer for the specific depot-
    crossdock combination as function of time. Note that this function differs from the 'generate_afvoer_df' function.
    In the 'generate_afvoer_df' function, the total afvoer is computed without accounting for inter transports. The
    present function adds afvoer per time-step, while the function 'add_inter_transports' adds the effects of inter
    transports. (Noot.. dit kan mogelijk versimpeld door in een keer inter transport vd lijn af te trekken)
    :param df_afv: DataFrame containing afvoer at specific times
    :param afv: DataFrame containing total afvoer for each depot-crossdock combination based on afvoerlijnvoorspeller
    :param afv_scanned: DataFrame containing total afvoer for each depot-crossdock combination based on scan data
    :param afv_time: DataFrame containing afvoer as function of time for the specific depot-crossdock combination
    :param origin: Depot of origin
    :param destination: Crossdock
    :param time: Time at which the afvoer arrives
    :return afv: DataFrame containing total afvoer for each depot-crossdock combination based on afvoerlijnvoorspeller
    :return afv_scanned: DataFrame containing total afvoer for each depot-crossdock combination based on scan data
    :return afv_time: DataFrame containing afvoer as function of time for the specific depot-crossdock combination
    """
    if time in list(df_afv.date_time):
        afv_row = df_afv[df_afv['date_time'] == time]
        afv_t = afv_row['rc_forecast'].iloc[0]
        afv.loc[origin, destination] += afv_t
        row = pd.DataFrame([[time, 'Prediction', afv_t, afv.loc[origin, destination], ]],
                            columns=afv_time[(origin, destination)].columns)
        afv_time[(origin, destination)] = pd.concat([afv_time[(origin, destination)], row])
    return afv_time


def add_inter_transports(afv, afv_time, df_int, origin, destination, time, max_load):
    """
    Function to add the effects of inter transports on the stock of rollcages present at a depot. For each inter-
    transport, we remove a full load from the stock. I the stock is already less than a full load, the transport takes
    all remaining rollcages
    :param afv: DataFrame containing the total afvoer for each depot-crossdock combinations based on afvoervoorspeller
    :param afv_scanned: DataFrame containing the total afvoer for each depot-crossdock combinations based on scan data
    :param afv_time: DataFrame containing afvoer as function of time for the specific depot-crossdock combination
    :param df_int: DataFrame containing inter transports
    :param origin:Depot of origin
    :param destination: Crossdock
    :param time: Current time
    :param max_load: Max. load for a trailer
    :return afv: DataFrame containing the total afvoer for each depot-crossdock combinations based on afvoervoorspeller
    :return afv_scanned: DataFrame containing the total afvoer for each depot-crossdock combinations based on scan data
    :return afv_time: DataFrame containing afvoer as function of time for the specific depot-crossdock combination
    """
    df_int.drop_duplicates(subset="Dagorder nummer", keep='first', inplace=True)
    if time in list(df_int.loading_time):

        if (origin, destination) in afv_time.keys():
            row = pd.DataFrame([[time, 'Inter', -max_load, afv.loc[origin, destination]]],
                                 columns=afv_time[(origin, destination)].columns)
            afv_time[(origin, destination)] = pd.concat([afv_time[(origin, destination)], row])
        else:
            afv_time[(origin, destination)] = afv_time[(origin, destination)].append(
                pd.Series([time, 'Inter',  0, 0], index=afv_time[(origin, destination)].columns), ignore_index=True)
    return afv_time


def update_inter_transports(afv_time, df_int, time, max_load):
    """
    Function to add the effects of inter transports on the stock of rollcages present at a depot. For each inter-
    transport, we remove a full load from the stock. If the stock is already less than a full load, the transport takes
    all remaining rollcages
    :param afv_time: DataFrame containing afvoer as function of time for the specific depot-crossdock combination
    :param df_int: DataFrame containing inter transports
    :param time: Current time
    :param max_load: Max. load for a trailer
    :return afv: DataFrame containing the total afvoer for each depot-crossdock combinations based on afvoervoorspeller
    :return afv_scanned: DataFrame containing the total afvoer for each depot-crossdock combinations based on scan data
    :return afv_time: DataFrame containing afvoer as function of time for the specific depot-crossdock combination
    """
    # In the loop below, we remove inter transports from the dataframe documenting changes in the number of RC on the
    # floor. The reason that these are removed is to replace them with the most recent numbers
    for ind, row in afv_time.iterrows():
        if row['date_time'] > config.current_time and row['event'] == 'Inter':
            afv_time.drop(index=ind, inplace=True)

    # In the loop below we add the most recent version of planned inter transports to the df
    df_int.drop_duplicates(subset="Dagorder nummer", keep='first', inplace=True)
    for index, row in df_int.iterrows():
        # Note, the if statement in the line below  should be changed in the final version to contain only planned
        # transports and not delivered transports, Currently it includes delivered transports to accomodate use of
        # historical data
        if row['Status'] == 'Planned' or (row['Status'] == 'Delivered' and row['loading_time'] > time):
            loading_time = row['loading_time']
            row = pd.DataFrame([[loading_time, -max_load, 'Inter', 0]], columns=afv_time.columns)
            afv_time = pd.concat([afv_time, row])
    afv_time.sort_values(by=['date_time'], inplace=True)
    return afv_time


def add_order_to_afvoer_rt(afv_time, time, origin, destination, order):
    """
    Function to add the effects of a flex order to the afvoerlijn
    :param afv_time: Afvoer as function of time, per depot-crossdock combination
    :param time: Time of flex order
    :param origin: Origin of flex order
    :param destination: Destination of flex order
    :param truck_cap: Max load of a truck (in rollcages)
    :return: Afvoer as function of time, per depot-crossdock combination, updated with effects of flex orders
    """
    df = afv_time[afv_time['date_time'] >= time]
    new_stock = df[df['date_time'] == time]['stock_corrected'].iloc[-1] - order.Size
    old_stock = df['stock'].iloc[0]

    row = pd.DataFrame([[time, -order.Size, 'Flex', old_stock, new_stock]], columns=afv_time.columns)
    afv_time = pd.concat([afv_time, row])
    afv_time = afv_time.sort_values(['date_time', 'event'], ascending=[True, False])

    afv_time.reset_index(inplace=True, drop=True)
    for index, row in afv_time.iterrows():
        t = row.date_time
        if t > time:
            afv_time.loc[index, 'stock_corrected'] -= order.Size
    return afv_time


def add_final_orders_rt(afv_time, time, ord_size):
    """
    Function to add any final flex orders, if rollcages are left at the end of the process
    :param afv_time: Afvoer as function of time, per depot-crossdock combination
    :param df_fc: Dataframe containing stock as function of time (noot: hoe zit dit precies)
    :param time: Time of flex order
    :param origin: Origin of flex order
    :param destination: Destination of flex order
    :param ord_size: Size of added flex order (number of rollcages)
    :return: Updated version of 'afv_time'
    """
    df = afv_time[afv_time['date_time'] >= time]
    new_stock = afv_time['stock_corrected'].iloc[-1] - ord_size
    old_stock = df['stock'].iloc[0]
    predicted_load = -ord_size

    row = pd.DataFrame([[time, predicted_load, 'Flex', old_stock, new_stock]], columns=afv_time.columns)
    afv_time = pd.concat([afv_time, row])

    return afv_time


def check_flex_order(df, rc_thresh, rc_thresh_future, time):
    """
    Check if a flex order should be made, given the expected aanvoerlijn
    :param df_fc: DataFrame containing expected aanvoerlijn
    :param rc_thresh: Threshold for current stock above which a flex order is made
    :param rc_thresh_future: Threshold for min. future stock above which a flex order is made
    :return: True is a flex order should be made, False otherwise
    """
    df = df[df['date_time'] >= time]
    if len(df['stock_corrected']) > 1:
        if df['stock_corrected'].iloc[0] >= rc_thresh:
            if all(elem >= rc_thresh_future for elem in df['stock_corrected'].iloc[1:]):
                return True
    return False


def update_afvoer(afv_time, time, rc_floor):
    """
    Function to update the afvoer prediction for a specific origin and destination. The scanned number of rollcages
    since the previous time-step is added to the stock, replacing the prediction that was made by the afvoervoorspeller.
    Predictions for the future time-steps are also updated. Currently, we assume that the scanned rollcages in the
    current and previous time-step do not directly influence the future predictions. Thus, the predicted scans for
    future time-steps are added to the scans in the current time-step.
    :param afv_time: Predictions of afvoer as function of time.
    :param time: Current time
    :return: Updated afvoer predictions
    """
    first_pred = 0
    afv_time.reset_index(inplace=True, drop=True)
    for index, row in afv_time.iterrows():
        if row['date_time'] >= time:
            if first_pred == 1:
                afv_time.loc[index, 'stock'] = max(0, afv_time.loc[index - 1, 'stock'] + row['rc_forecast'])
            else:
                afv_time.loc[index, 'stock'] = rc_floor
                first_pred = 1
    return afv_time


def create_new_order_realtime(time, truck_cap, origin, destination, afv_orders):
    """
    Function to create a flex order. The flex order is added to the list of all flex orders, and to a list of flex
    orders for the specific depot-crossdock combination
    :param time: Time of the flex order
    :param truck_cap: Max. truck capacity
    :param origin: Starting place of flex order
    :param destination: Destination of flex order
    :param afv_orders: Dictionary containing lists of flex orders for depot-crossdock combinations
    :return: Updated versions of 'afv_orders'
    """
    new_ord = Order(time, truck_cap, origin, destination)
    afv_orders.append(new_ord)
    return afv_orders


def get_floor_stock(origin, destination, current_time, afvoer):
    """
    Get an assessment of the current stock at a depot of origin, intended for transport to a specific destination.
    Currently, this is a dummy function that returns the predicted stock with some deviation. This dummy function should
    be replaced when the model is coupled to the real data scource
    :param origin: Depot of origin
    :param destination: Destination
    :param current_time: Time
    :param afvoer: predicted afvoer (used only in the dummy function)
    :return:
    """
    predicted_afvoer = afvoer[afvoer['date_time'] <= current_time]['stock'].iloc[-1]
    stock = max(0, predicted_afvoer + random.randint(-10, 10))
    return stock


def read_cleaned_VAR_data(path_transport):
    """
    Read transport data from VAR that was already cleaned to filter the relevant rides and columns
    Args:
        path_transport: path for reading the data

    Returns: dataframe containing the transport data

    """
    df = pd.read_csv(path_transport, sep=',')
    df['loading_time'] = df['loading_time'].apply(lambda x: datetime.datetime.strptime(x, '%Y-%m-%d %H:%M:%S'))
    return df


def generate_stock_prediction(df_afvoer, df_inter):
    """
    In htis function the forecasted numbers of scanned rolcages are combined with the planned inter transports in order
    to obtain an estimate of the number of RC present on the depot floor, as function of time
    Args:
        df_afvoer: Dataframe containing forecasted numbers of scanned rollcages for 15 minute time intervals
        df_inter: Dataframe containing planned inter transports

    Returns:
        Dataframe containing predicted numbers of scanned RC, planned inter transport, and corresponding estimates of
        RC on the floor over 15 minute intervals.

    """
    df_afvoer = df_afvoer[['date_time', 'rc_forecast']].copy()   #
    df_afvoer['event'] = 'Prediction'
    df_afvoer['stock'] = 0

    if len(df_inter) > 0:
        df_inter = df_inter[['loading_time', 'RC groot equivalent gepland']].copy()
        df_inter.loc[:, 'event'] = 'Inter'
        df_inter.loc[:, 'stock'] = 0
        df_inter['RC groot equivalent gepland'] = -df_inter['RC groot equivalent gepland']
        df_inter.columns = df_afvoer.columns
        df_stock = pd.concat([df_afvoer, df_inter])
    else:
        df_stock = df_afvoer.copy()

    df_stock.sort_values(by='date_time', inplace=True)
    df_stock.reset_index(inplace=True, drop=True)
    df_stock.loc[0, 'stock'] = df_stock.loc[0, 'rc_forecast']
    for ind, row in df_stock.iterrows():
        if ind > 0:
            df_stock.loc[ind, 'stock'] = max(0, df_stock.loc[ind - 1, 'stock'] + df_stock.loc[ind, 'rc_forecast'])
    return df_stock


def add_flex_orders(afvoer, time, origin, destination):
    """
    This function checks whether flex orders are needed, and creates any needed orders
    Args:
        afvoer: df containing predictions for afvoer for the remainder of the process
        time: current time
        origin: depot of origin
        destination: destination depot

    Returns:
        afvoer: df containing predictions for afvoer for the remainder of the process, updated with flex orders
        afvoer_orders: list of needed flex orders
    """
    afvoer_orders = []    # initialize list of needed extra orders to solve 'afvoertekorten'
    # Initialize 'corrected stock', which estimates the number of RC on the floor while deducting Flex orders
    afvoer['stock_corrected'] = afvoer['stock']
    # Loop over 15 min. intervals. For each interval it is checked whether one or multiple flex orders are needed
    for t in list(afvoer[afvoer['date_time'] >= time].date_time):
        while check_flex_order(afvoer, config.rc_threshold, config.rc_threshold_future, t):
            afvoer_orders = create_new_order_realtime(t, config.truck_capacity, origin, destination, afvoer_orders)
            afvoer = add_order_to_afvoer_rt(afvoer, t, origin, destination, afvoer_orders[-1])
    # Below, it is checked whether any additional flex order is needed at the end of the process
    if len(afvoer) > 0:
        while afvoer['stock_corrected'].iloc[-1] > 0:
            order_size = np.min([config.truck_capacity, afvoer['stock_corrected'].iloc[-1]])
            t = afvoer['date_time'].iloc[-1]
            afvoer_orders = create_new_order_realtime(t, order_size, origin, destination, afvoer_orders)
            afvoer = add_final_orders_rt(afvoer, t, order_size)
    return afvoer, afvoer_orders
